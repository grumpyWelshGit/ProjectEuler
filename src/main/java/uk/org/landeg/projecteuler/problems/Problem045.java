package uk.org.landeg.projecteuler.problems;

import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import uk.org.landeg.projecteuler.ProblemDescription;

@Order(45)
@Component
public class Problem045 implements ProblemDescription<Long>{
	private static final Logger LOG = LoggerFactory.getLogger(Problem045.class);
	@Override
	public String getTask() {
		return "Find the next triangle number that is also pentagonal and hexagonal";
	}

	@Override
	public String getDescribtion() {
		return "Triangle, pentagonal, and hexagonal numbers are generated by the following formulae : It can be verified that T285 = P165 = H143 = 40755";
	}

	@Override
	public Long solve() {
		long np = 160, nh = 140;
		long p = 0, h = 0;
		do {
			if (p == 0 || p == 1 || p < h) {
				np++;
				p = np * (3 * np - 1) / 2;	
			}
			if (h == 0 || h == 1 || h < p) {
				nh++;
				h = nh * (2 * nh - 1);
			}
			if (h == p) {
				LOG.info("Discovered equality np={} nh={} h={}", np, nh, h);
				if (h > 40755) {
					LOG.info("h exceeds 40755 ({})", h);
					break;
				}
				p=0;
			}
		} while (p != h || p <= 40755);
		LOG.info("Escacpe conditions, p {} h {}", p, h);
		return p;
	}

	private static final Map<Integer, Long> triangles = new HashMap<Integer, Long>();
	private static final Map<Integer, Long> pentagons = new HashMap<Integer, Long>();
	private static final Map<Integer, Long> hexagons = new HashMap<Integer, Long>();
	
	private long pentagon (final int n) {
		return addToSequenceCache(n, hexagons, x -> 3l * x * x - (long) x);
	}
	
	private long hexagon (final int n) {
		return addToSequenceCache(n, hexagons, x -> 4l * x * x - 2l * x);

	}
	
	private long triangle (final int n) {
		return addToSequenceCache(n, triangles, x -> x * (x + 1));
	}
	
	private long addToSequenceCache (
			final int n,
			final Map<Integer, Long> map,
			final SequenceOperator operator) {
		if (map.containsKey(n)) {
			return map.get(n);
		} else {
			final long s = operator.transform(n);
			map.put(n, s);
			return s;
		}
	}
	
	@FunctionalInterface
	private static interface SequenceOperator {
		public long transform (final int n);
	}
}
